use std::{collections::HashSet, vec};

/// The InputEvent enum represents the different types of input events that can be generated by Streamdeck devices.
/// Most streamdeck devices only have buttons, the Streamdeck Plus also has dials and a segmented touchscreen.
#[derive(Debug, Clone)]
#[cfg_attr(feature = "serde", derive(serde::Deserialize, serde::Serialize))]
pub enum InputEvent {
    Button {
        index: u8,
        released: bool,
    },
    Dial {
        index: u8,
        ///Press will have a value if the dial was pressed or released, None if the dial was turned
        press: Option<bool>,
        ///Delta will have a value if the dial was turned, None if the dial was pressed or released
        delta: Option<i8>,
    },
    ///The segment is the index of the segment that was touched, x and y are the coordinates of the touch on the segment
    Touch {
        segment: u8,
        x: u8,
        y: u8,
    },
}

#[derive(Debug, Clone)]
pub struct InputManager {
    pressed_keys: HashSet<u8>,
    pressed_dials: HashSet<u8>,
}

impl InputManager {
    pub fn new() -> Self {
        InputManager {
            pressed_keys: HashSet::new(),
            pressed_dials: HashSet::new(),
        }
    }

    pub fn handle_sd_plus_input(
        &mut self,
        cmd: &[u8; 12],
    ) -> Result<Vec<InputEvent>, crate::Error> {
        let event = match cmd[1] {
            0 => self.handle_button_event(&cmd, 3),
            2 => self.handle_touchscreen_event(&cmd),
            3 => self.handle_dial_event(&cmd, 5),
            _ => return Err(crate::Error::InvalidInputTypeIndex),
        };
        Ok(event)
    }

    fn handle_touchscreen_event(&self, cmd: &[u8; 12]) -> Vec<InputEvent> {
        vec![InputEvent::Touch {
            segment: cmd[7],
            x: cmd[6],
            y: cmd[8],
        }]
    }

    fn handle_dial_event(&mut self, cmd: &[u8; 12], offset: u8) -> Vec<InputEvent> {
        let press = cmd[4] == 0;
        let mut events = Vec::new();
        if !press {
            for i in offset..offset + 4 {
                if cmd[i as usize] == 0 {
                    continue;
                }
                let delta: i8;
                if cmd[(i) as usize] > 127 {
                    delta = -((255 - cmd[(i) as usize]) as i8) -1; //convert to signed 8-bit and invert. subtract 1 to make it 0-based
        
                } 
                else {
                    delta = cmd[(i) as usize] as i8;
                }
                events.push(InputEvent::Dial {
                    index: i - offset,
                    press: None,
                    delta: Some(delta),
                });
            }

            return events;
        }
        let mut fresh_presses = HashSet::new();
        for i in offset..offset + 4 {
            if cmd[i as usize] == 1 {
                let dial = (i - offset) as u8;
                if self.pressed_dials.contains(&dial) {
                    continue;
                }
                fresh_presses.insert(dial);
                events.push(InputEvent::Dial {
                    index: dial,
                    press: Some(press),
                    delta: None,
                });
            }
        }
        self.pressed_dials.retain(|dial| {
            if cmd[(offset + *dial) as usize] == 0 && !fresh_presses.contains(dial) {
                events.push(InputEvent::Dial {
                    index: *dial,
                    press: Some(!press),
                    delta: None,
                });
                return false;
            }
            true
        });
        self.pressed_dials.extend(fresh_presses);
        events
    }

    fn handle_button_event(&mut self, cmd: &[u8; 12], offset: usize) -> Vec<InputEvent> {
        let mut fresh_presses = HashSet::new();
        let mut events = Vec::new();

        // Iterate over the buttons in the command
        for i in 4..cmd.len() {
            if cmd[i] == 0 {
                continue;
            }
            let button = (i - offset - 1) as u8;
            // If the button was already reported as pressed, skip it
            if self.pressed_keys.contains(&button) {
                continue;
            }

            // If the button press is fresh, add it to the fresh_presses HashSet and the events Vec
            fresh_presses.insert(button);
            events.push(InputEvent::Button {
                index: button,
                released: false,
            });
        }

        // Remove released buttons from the pressed_keys HashSet and add them to the events Vec as released
        self.pressed_keys.retain(|button| {
            if cmd[offset + *button as usize + 1] == 0 && !fresh_presses.contains(button) {
                events.push(InputEvent::Button {
                    index: *button,
                    released: true,
                });
                return false;
            }
            true
        });

        // Add the fresh_presses HashSet to the pressed_keys HashSet
        self.pressed_keys.extend(fresh_presses);
        events
    }
}
